package tracecsv;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Scanner;

import structuralAnalysis.ClassDiagram;

/**
 * Console application to dyanamic analysis and generate the outputs
 * @author Shashidar Ette - se146
 *
 */
public class DynamicCodeAnalyser {
	public static void main(String[] args) throws IOException {
		int numberOfTopClasses = 100;
		String traceFileFolder = 
				"C:\\Users\\Shashi\\Documents\\MS\\SEM2\\SRE\\Assignment2\\assignment2-shashidarette\\dataFiles\\outputs\\TraceFiles";
		
		String classRootDir = 
				"C:\\Users\\Shashi\\Documents\\MS\\SEM2\\SRE\\Assignment2\\assignment2-shashidarette\\jfreechart\\target\\classes";
				
		String mainJarPath = 
				"C:\\Users\\Shashi\\Documents\\MS\\SEM2\\SRE\\Assignment2\\assignment2-shashidarette\\jfreechart\\target" + 
							"\\jfreechart-1.5.0-SNAPSHOT-jar-with-dependencies.jar";
		
		String consoleOutput = "\r\n[                          Welcome to Dynamic Code Analyzer                               ]\r\n" +
							   "This application will process the trace files generated by aspects.jar and process them to create several outputs.\r\n" +
							   "1. Generate the summary of the process as Classes.csv, Methods.csv" +
							   "2. list of Topmost Classes based on the total occurence \r\n" +
							   "3. Class relationship dot file to Dot application to generate the class diagram" +
							   "4. Generate the time series data to analyzed using the PhaseAnalysis.R script.\r\n"; 
		
		Scanner sc = new Scanner(System.in);
		
		try {
			System.out.println(consoleOutput);
			
			System.out.println("Please select the folder with trace files (generated using the aspects.jar):");
			traceFileFolder = sc.nextLine();
			System.out.println("Please select the folder with classes (aka .class) files:");
			classRootDir = sc.nextLine();
			System.out.println("Please select the location of the main jar (used to generate trace files) required to generated class relationship dot file:");
			mainJarPath = sc.nextLine();			
			System.out.println("Please select the number of classes to be considered to generate class relationship dot file (based on total number of occurrences) for ex: 25:");
			numberOfTopClasses = Integer.parseInt(sc.nextLine());
			
			List<String> traceFiles = DataFileManager.identifyDataFiles(traceFileFolder);
			
			TraceAnalyzer analyser = new TraceAnalyzer(traceFiles);
			analyser.analyze();
			createOutputsFolder();
			System.out.println("Classes CSV");
			String classesCSV = analyser.generateClassesCSV();
			writeFile("./Outputs/classes.csv", classesCSV);
			System.out.println("Generated classes.csv file.\r\n");
			
			System.out.println("Methods CSV");
			String methodsCSV = analyser.generateMethodsCSV();
			writeFile("./Outputs/methods.csv", methodsCSV);
			System.out.println("Generated methods.csv file.\r\n");
			
			
			System.out.println("Top " + numberOfTopClasses + " classes are:");
			List<LogEntry> desiredClasses = analyser.getTopmostClasses(numberOfTopClasses);
			String topClasses = getListAsString(desiredClasses);
			writeFile("./Outputs/Top" + numberOfTopClasses + "Classes.csv", topClasses);
			System.out.println("Generated " + "Top" + numberOfTopClasses + "Classes.csv file.\r\n");
			
			System.out.println("Class Relationship and Association diagram (.dot format):");
			ClassDiagram classDiagram = new ClassDiagram(classRootDir, desiredClasses, mainJarPath, true, true);
			String classDiagramDot = classDiagram.analyze();
			writeFile("./Outputs/classDiagram.dot", classDiagramDot);
			System.out.println("Generated classDiagram.dot file (use dot to generate the class diagram).\r\n");
			
			System.out.println("Time Series");
			List<String> timeSeriesList = analyser.generatePhaseAnalysis();
			int index = 1;
			for (String timeSeriesData : timeSeriesList) {
				writeFile("./Outputs/timeseries" + index + ".csv", timeSeriesData);
				System.out.println("Generated " + "timeseries" + index + ".csv file.");
				index++;
			}
			System.out.println("All the outputs are generated in [Outputs] folder.");
		} catch (IOException iex) {
			System.out.println("An IO or File exception occured during the processing.");
			iex.printStackTrace();
		} catch (Exception ex) {
			System.out.println("An exception occured during the processing.");
			ex.printStackTrace();
		}

		sc.close();
		
	}
	
	// Utility function to create the Outputs folder
	private static void createOutputsFolder() {
		File outputDir = new File("Outputs");
		
		// if does not exist
		if (!outputDir.exists()) {
			outputDir.mkdirs();
		}
	}
	/**
	 * Utility function to generate list of log entry as String
	 * @param loglist
	 * @return
	 */
	private static String getListAsString(List<LogEntry> loglist) {		
		StringBuilder sb = new StringBuilder();
		sb.append("Name, TotalOccurances\r\n");
		for (LogEntry log : loglist) {
			sb.append(log.getName() + ", " + log.getOccurance() + "\r\n");
			
		}
		return sb.toString();
	}
	
	/**
	 * Utility function to generate the file with required contents
	 * @param filePath
	 * @param fileContent
	 * @return
	 */
	private static boolean writeFile(String filePath, String fileContent) {
		boolean fileSaved = false;
		try {
			FileWriter fileWriter = new FileWriter(filePath);
			fileWriter.write(fileContent);
			fileWriter.close();
			fileSaved = true;
		} catch (Exception e) {
			System.out.println(e);
		}
		return fileSaved;
	}
}
